# 逻辑表达式

### 条件运算符的正确使用
尽量在if中这样写条件表达式:

    if(3==num)

因为如果错误的写成

    if(3=num)

编译器将会生成错误信息,它相当于为一个常量赋值,而这是绝对不可能的,所以可以快速找出问题

但是如果使用这种方法

    if(num=3)
`编译器只是把3赋给num,此时if语句块必执行`

### 读取数字的循环
假设要编写一个将一系列数读入到数组中的程序,并允许用户在数组填满之前结束输入,一种方法是用cin,如下面代码:

    int n;
    cin>>n;
如果用户输入一个单词,而不是一个数字,情况是如何呢?发生这种类型不匹配的情况时,将发生四个事件:
- n的值保持不变
- 不匹配的输入将被留在输入队列中
- cin对象中的一个错误标记被设置
- 对cin方法的调用将返回false
方法返回false意味着可以用非数字输入来结束读取数字的循环

非数字输入设置错误标记意味着必须重置该标记,程序才能继续读取输入

`clear()可以重置错误标记,同时也重置文件尾`

```cpp
    int weight[5];
    int i = 0, num = 0;
    do
    {
        if (!(cin >> weight[num]))
        {
            cin.clear();
            while (cin.get() != '\n')
            {
                continue;
            }                          //等效于 cin.sync()
            cout << "do it again\n";
            continue;
        }

        num++;
    } while (num < 5);
    for (int k = 0; k < num; k++)
    {
        printf("%d\n", weight[k]);
    }
```

上述代码中:
- cin.clear()用来重置输入,如果省略该语句,程序将拒绝继续读取输入  *不是用来清空缓冲区*
- cin.clear()后面三行用来清除错误输入,等效于`cin.sync()`

### ch+1 和++ch的区别

考虑下面代码:
    
    char c='a';
    cout<<++c<<endl;

    cout<<c+1<<endl;
 
第一个输出b  第二个输出99

`原因`:
- 第一个在ch这个字符变量自身的ASCII码上加1,成为99，但其还是字符变量
- 第二个输出ch+1 而1是int常量 使得ch变量转换为int类型,最后输出的自然是int类型